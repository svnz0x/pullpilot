<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PullPilot · Panel local</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg-color: #0f172a;
        --card-color: rgba(15, 23, 42, 0.6);
        --card-border: rgba(148, 163, 184, 0.35);
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --danger: #f87171;
        --success: #4ade80;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      }

      body {
        margin: 0;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 2.5rem 1.5rem 1rem;
        text-align: center;
      }

      header h1 {
        margin: 0;
        font-size: clamp(2rem, 5vw, 3rem);
        letter-spacing: -0.03em;
      }

      header p {
        margin: 0.75rem auto 0;
        max-width: 40rem;
        color: var(--text-secondary);
        line-height: 1.5;
      }

      body.requires-auth main {
        display: none;
      }

      body.authenticated main {
        display: grid;
      }

      body.requires-auth #login-screen {
        display: block;
      }

      body.authenticated #login-screen {
        display: none;
      }

      #login-screen {
        margin: 2rem auto 0;
        width: min(32rem, 92vw);
        background: rgba(15, 23, 42, 0.55);
        border-radius: 1.25rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        padding: clamp(1.5rem, 4vw, 2rem);
        box-shadow: 0 20px 35px rgba(15, 23, 42, 0.35);
        display: none;
      }

      #login-screen form {
        display: grid;
        gap: 1rem;
      }

      #login-screen label {
        font-weight: 600;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      #login-screen label.remember-token {
        flex-direction: row;
        align-items: center;
        gap: 0.75rem;
        font-weight: 500;
      }

      #login-screen label.remember-token input[type="checkbox"] {
        width: 1.15rem;
        height: 1.15rem;
        margin: 0;
        accent-color: var(--accent);
      }

      #login-screen label.remember-token .remember-token-text {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      #login-screen label.remember-token .remember-token-text strong {
        font-weight: 600;
      }

      #login-screen label.remember-token .remember-token-text span {
        font-size: 0.85rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      #login-screen input[type="password"] {
        width: 100%;
        padding: 0.7rem 0.85rem;
        border-radius: 0.9rem;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.35);
        color: inherit;
        font: inherit;
      }

      #login-screen input[type="password"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
      }

      .login-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .login-actions button {
        flex: 1 1 auto;
        min-width: 8rem;
      }

      .login-status {
        font-size: 0.95rem;
        color: var(--text-secondary);
        min-height: 1.35em;
      }

      .login-status.is-success {
        color: #bef264;
      }

      .login-status.is-error {
        color: #fecaca;
      }

      .logout-button {
        display: none;
        margin: 1.5rem auto 0;
      }

      body.authenticated .logout-button {
        display: inline-flex;
      }

      main {
        flex: 1 0 auto;
        width: min(1100px, 92vw);
        margin: 0 auto 3rem;
        display: grid;
        gap: 2rem;
      }

      section {
        background: var(--card-color);
        border-radius: 1.25rem;
        border: 1px solid var(--card-border);
        backdrop-filter: blur(18px);
        padding: clamp(1.5rem, 2vw, 2rem);
        box-shadow: 0 20px 35px rgba(15, 23, 42, 0.35);
      }

      section h2 {
        margin-top: 0;
        font-size: 1.5rem;
        letter-spacing: -0.015em;
      }

      .config-grid {
        display: grid;
        gap: 1.25rem;
      }

      .config-field {
        display: grid;
        gap: 0.5rem;
      }

      .config-field label {
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .config-field .field-input {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .config-field input[type="text"],
      .config-field input[type="number"],
      .config-field select,
      .config-field textarea {
        width: min(100%, 30rem);
        padding: 0.65rem 0.75rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.35);
        color: inherit;
        font: inherit;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        resize: vertical;
      }

      .config-field textarea.multiline-input {
        width: min(100%, 42rem);
        min-height: 6rem;
        line-height: 1.4;
      }

      .config-field input[type="checkbox"] {
        width: 1.25rem;
        height: 1.25rem;
        accent-color: var(--accent);
      }

      .config-field input:focus,
      .config-field select:focus,
      .config-field textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
      }

      .config-field .field-description {
        margin: 0;
        color: var(--text-secondary);
        line-height: 1.45;
        font-size: 0.95rem;
      }

      .config-field .field-default {
        display: inline-block;
        margin-top: 0.35rem;
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.8);
      }

      .form-actions {
        margin-top: 1.5rem;
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1.6rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      button.primary {
        background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
        color: #0f172a;
        box-shadow: 0 15px 30px rgba(56, 189, 248, 0.25);
      }

      button.secondary {
        background: rgba(148, 163, 184, 0.15);
        color: inherit;
      }

      button:hover {
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(1px);
      }

      .status {
        margin-top: 1rem;
        padding: 0.85rem 1rem;
        border-radius: 0.9rem;
        font-size: 0.95rem;
        background: rgba(148, 163, 184, 0.12);
        border: 1px solid rgba(148, 163, 184, 0.25);
        color: var(--text-secondary);
      }

      .status ul {
        margin: 0.5rem 0 0;
        padding-left: 1.25rem;
        display: grid;
        gap: 0.25rem;
      }

      .status li {
        margin: 0;
        padding: 0;
        list-style: disc;
      }

      .status.success {
        background: rgba(74, 222, 128, 0.18);
        border-color: rgba(74, 222, 128, 0.35);
        color: #bef264;
      }

      .status.error {
        background: rgba(248, 113, 113, 0.18);
        border-color: rgba(248, 113, 113, 0.35);
        color: #fecaca;
      }

      .config-field.is-error label {
        color: var(--danger);
      }

      .config-field.is-error .value-input,
      .config-field.is-error textarea[data-multiline] {
        border-color: rgba(248, 113, 113, 0.6);
        box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.25);
      }

      .logs-header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .logs-header select {
        min-width: 14rem;
      }

      .log-meta {
        font-size: 0.85rem;
        color: var(--text-secondary);
      }

      .log-output {
        background: rgba(15, 23, 42, 0.55);
        border-radius: 1rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        padding: 1rem;
        margin-top: 1rem;
        max-height: 24rem;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.85rem;
        line-height: 1.45;
      }

      @media (max-width: 768px) {
        main {
          gap: 1.25rem;
        }

        section {
          padding: 1.25rem;
        }

        .config-field input[type="text"],
        .config-field input[type="number"],
        .config-field select,
        .config-field textarea {
          width: 100%;
        }

        .config-field textarea.multiline-input {
          width: 100%;
        }
      }
    </style>
  </head>
  <body class="requires-auth">
    <header>
      <h1>PullPilot</h1>
      <p>
        Administra los parámetros del script de actualización y revisa los últimos logs directamente desde
        tu navegador. Introduce el token bearer que protege la API para habilitar la interfaz y recuerda el
        token solo en dispositivos de confianza.
      </p>
      <button type="button" class="secondary logout-button" id="logout-button">Olvidar token actual</button>
    </header>
    <section id="login-screen">
      <form id="token-form" autocomplete="off">
        <label for="token-input">
          Token bearer
          <input
            id="token-input"
            name="token"
            type="password"
            placeholder="Introduce tu token"
            aria-describedby="login-status"
            autocomplete="off"
            autocapitalize="off"
            spellcheck="false"
            required
          />
        </label>
        <label for="remember-token" class="remember-token">
          <input type="checkbox" id="remember-token" name="remember-token" />
          <span class="remember-token-text">
            <strong>Recordar token en este navegador</strong>
            <span>Evita marcar esta opción en equipos compartidos o públicos.</span>
          </span>
        </label>
        <div class="login-actions">
          <button type="submit" class="primary">Iniciar sesión</button>
          <button type="button" class="secondary" id="clear-token">Olvidar token</button>
        </div>
        <span class="login-status" id="login-status" role="status" aria-live="polite"></span>
      </form>
    </section>
    <main>
      <section id="config-section">
        <h2>Configuración del updater</h2>
        <form id="config-form">
          <div class="config-grid" id="config-fields"></div>
          <div class="form-actions">
            <button type="submit" class="primary">Guardar cambios</button>
            <button type="button" class="secondary" id="reset-config">Descartar cambios</button>
          </div>
        </form>
        <div class="status" id="config-status" role="status" aria-live="polite" hidden></div>
      </section>

      <section id="logs-section">
        <h2>Logs recientes</h2>
        <div class="logs-header">
          <label for="log-select">Archivo</label>
          <select id="log-select"></select>
          <button type="button" class="secondary" id="refresh-logs">Actualizar</button>
          <span class="log-meta" id="log-meta"></span>
        </div>
        <div class="status" id="logs-status" role="status" aria-live="polite" hidden></div>
        <pre class="log-output" id="log-content">Cargando logs…</pre>
      </section>
    </main>
    <script>
      (() => {
        const body = document.body;
        const loginForm = document.getElementById("token-form");
        const tokenInput = document.getElementById("token-input");
        const loginStatus = document.getElementById("login-status");
        const clearTokenButton = document.getElementById("clear-token");
        const rememberCheckbox = document.getElementById("remember-token");
        const logoutButton = document.getElementById("logout-button");
        const form = document.getElementById("config-form");
        const fieldsContainer = document.getElementById("config-fields");
        const resetButton = document.getElementById("reset-config");
        const configStatus = document.getElementById("config-status");
        const logSelect = document.getElementById("log-select");
        const logContent = document.getElementById("log-content");
        const logMeta = document.getElementById("log-meta");
        const logsStatus = document.getElementById("logs-status");
        const refreshLogs = document.getElementById("refresh-logs");

        const TOKEN_STORAGE_KEY = "pullpilot.bearerToken";
        let lastConfigSnapshot = null;
        let memoryToken = null;
        let storedToken = null;

        const buildApiUrl = (() => {
          let cachedBase = null;

          const hasProtocol = (value) => /^[a-zA-Z][a-zA-Z\d+.-]*:/.test(value);

          const resolveBase = () => {
            if (cachedBase) {
              return cachedBase;
            }

            const baseElement = document.querySelector("base[href]");
            if (baseElement) {
              const href = baseElement.getAttribute("href");
              if (href) {
                try {
                  cachedBase = new URL(href, window.location.href);
                  return cachedBase;
                } catch (error) {
                  console.warn("Base href inválido; se ignorará.", error);
                }
              }
            }

            const { origin, pathname } = window.location;
            const marker = "/ui/";
            let basePath = "/";

            if (pathname.endsWith("/ui")) {
              basePath = `${pathname}/`;
            } else if (pathname.includes(marker)) {
              basePath = pathname.slice(0, pathname.indexOf(marker) + marker.length);
            } else if (pathname.endsWith("/")) {
              basePath = pathname;
            } else {
              const lastSlashIndex = pathname.lastIndexOf("/");
              basePath = lastSlashIndex >= 0 ? pathname.slice(0, lastSlashIndex + 1) : "/";
            }

            try {
              cachedBase = new URL(basePath, origin);
            } catch (error) {
              console.warn("No se pudo resolver la base a partir de window.location.", error);
              cachedBase = new URL("/", origin);
            }
            return cachedBase;
          };

          return (path = "") => {
            if (path instanceof URL) {
              return path.toString();
            }

            const normalized = typeof path === "string" ? path.trim() : "";
            if (!normalized) {
              return resolveBase().toString();
            }

            if (hasProtocol(normalized)) {
              return normalized;
            }

            const relative = normalized.startsWith("/")
              ? normalized.slice(1)
              : normalized;
            return new URL(relative, resolveBase()).toString();
          };
        })();

        const showLoginMessage = (message, tone = "info") => {
          if (!loginStatus) return;
          loginStatus.textContent = message;
          loginStatus.classList.toggle("is-success", tone === "success");
          loginStatus.classList.toggle("is-error", tone === "error");
        };

        const STORAGE_FAILURE_MESSAGES = {
          read:
            "No se pudo acceder al almacenamiento local en este navegador. El token no se recordará automáticamente.",
          write:
            "No se pudo recordar el token en este navegador. El token solo estará disponible en esta sesión.",
          remove:
            "No se pudo actualizar el token almacenado en este navegador. El token podría seguir guardado.",
          clear:
            "No se pudo olvidar el token almacenado en este navegador. Es posible que debas borrarlo manualmente.",
          generic: "No se pudo acceder al almacenamiento local en este navegador.",
        };

        const disableRememberTokenOption = () => {
          if (!rememberCheckbox) return;
          rememberCheckbox.checked = false;
          rememberCheckbox.disabled = true;
          rememberCheckbox.setAttribute("data-storage-unavailable", "true");
        };

        const processStorageStatus = (
          status,
          { message, tone = "error", silent = false } = {},
        ) => {
          if (!status) {
            return { handled: false };
          }

          if (status.ok === false) {
            disableRememberTokenOption();
            const resolvedMessage =
              message ||
              STORAGE_FAILURE_MESSAGES[status.operation] ||
              STORAGE_FAILURE_MESSAGES.generic;
            if (!silent) {
              showLoginMessage(resolvedMessage, tone);
            }
            return {
              handled: true,
              message: resolvedMessage,
              tone,
              status,
            };
          }

          return { handled: false, status };
        };

        const readStoredTokenStatus = () => {
          try {
            const token = window.localStorage.getItem(TOKEN_STORAGE_KEY) || null;
            return { ok: true, operation: "read", token };
          } catch (error) {
            return { ok: false, operation: "read", error };
          }
        };

        const storedTokenStatus = readStoredTokenStatus();
        storedToken = storedTokenStatus.ok ? storedTokenStatus.token : null;
        const initialStorageOutcome = processStorageStatus(storedTokenStatus, {
          silent: true,
        });

        const resetPortalState = () => {
          if (fieldsContainer) {
            fieldsContainer.innerHTML = "";
          }
          lastConfigSnapshot = null;
          if (configStatus) {
            configStatus.hidden = true;
            configStatus.classList.remove("success", "error");
            configStatus.textContent = "";
          }
          if (logsStatus) {
            logsStatus.hidden = true;
            logsStatus.classList.remove("success", "error");
            logsStatus.textContent = "";
          }
          if (logSelect) {
            logSelect.innerHTML = "";
            logSelect.disabled = true;
          }
          if (logContent) {
            logContent.textContent = "Introduce un token válido para ver los logs.";
          }
          if (logMeta) {
            logMeta.textContent = "";
          }
        };

        const setAuthState = (isAuthenticated) => {
          body.classList.toggle("authenticated", isAuthenticated);
          body.classList.toggle("requires-auth", !isAuthenticated);
          if (!isAuthenticated) {
            resetPortalState();
          }
        };

        const auth = {
          getToken: () => memoryToken,
          setToken: (token, { persist = false } = {}) => {
            const trimmed = typeof token === "string" ? token.trim() : "";
            memoryToken = trimmed || null;

            if (!memoryToken) {
              try {
                window.localStorage.removeItem(TOKEN_STORAGE_KEY);
                return { ok: true, operation: "remove", persisted: false };
              } catch (error) {
                return { ok: false, operation: "remove", error };
              }
            }

            if (persist) {
              try {
                window.localStorage.setItem(TOKEN_STORAGE_KEY, memoryToken);
                return { ok: true, operation: "write", persisted: true };
              } catch (error) {
                return { ok: false, operation: "write", error };
              }
            }

            try {
              window.localStorage.removeItem(TOKEN_STORAGE_KEY);
              return { ok: true, operation: "remove", persisted: false };
            } catch (error) {
              return { ok: false, operation: "remove", error };
            }
          },
          clearToken: () => {
            memoryToken = null;
            try {
              window.localStorage.removeItem(TOKEN_STORAGE_KEY);
              return { ok: true, operation: "clear" };
            } catch (error) {
              return { ok: false, operation: "clear", error };
            }
          },
        };

        const verifyToken = async (candidate, { persist = false } = {}) => {
          const token = typeof candidate === "string" ? candidate.trim() : "";
          if (!token) {
            const error = new Error("TOKEN_REQUIRED");
            error.code = "TOKEN_REQUIRED";
            throw error;
          }

          let response;
          try {
            response = await fetch(buildApiUrl("auth-check"), {
              headers: { Authorization: `Bearer ${token}` },
            });
          } catch (error) {
            const networkError = new Error("NETWORK_ERROR");
            networkError.cause = error;
            throw networkError;
          }

          let payload = null;
          let payloadError = null;
          if (response.status !== 204) {
            try {
              payload = await response.json();
            } catch (error) {
              payloadError = error;
            }
          }

          if (response.status === 401) {
            const error = new Error("UNAUTHORIZED");
            error.status = response.status;
            if (!payloadError) {
              error.payload = payload;
            }
            throw error;
          }

          if (!response.ok) {
            const error = new Error("REQUEST_FAILED");
            error.status = response.status;
            if (!payloadError) {
              error.payload = payload;
            }
            throw error;
          }

          if (payloadError) {
            const invalidResponseError = new Error("INVALID_RESPONSE");
            invalidResponseError.cause = payloadError;
            throw invalidResponseError;
          }

          const storageStatus = auth.setToken(token, { persist });
          return { success: true, storageStatus };
        };

        const createUnauthorizedError = () => {
          const error = new Error("UNAUTHORIZED");
          error.status = 401;
          return error;
        };

        const resolveUnauthorizedDetails = (error, fallbackMessage) => {
          const payload = error?.payload;
          const fallback = typeof fallbackMessage === "string" ? fallbackMessage : "";
          const ignoredMessages = new Set(["missing credentials", "unauthorized"]);
          const defaultResult = { message: fallback, reason: "unknown" };

          const gatherMessages = (...sources) => {
            const results = [];
            const visitedObjects =
              typeof WeakSet === "function" ? new WeakSet() : new Set();

            const pushMessage = (value) => {
              const trimmed = value.trim();
              if (!trimmed) return;
              const normalized = trimmed.toLowerCase();
              if (ignoredMessages.has(normalized)) return;
              if (!results.includes(trimmed)) {
                results.push(trimmed);
              }
            };

            const visit = (value) => {
              if (value == null) {
                return;
              }
              if (typeof value === "string") {
                pushMessage(value);
                return;
              }
              if (Array.isArray(value)) {
                value.forEach(visit);
                return;
              }
              if (typeof value === "object") {
                if (visitedObjects.has(value)) return;
                visitedObjects.add(value);
                const prioritizedKeys = [
                  "detail",
                  "details",
                  "description",
                  "message",
                  "error",
                  "msg",
                  "hint",
                  "title",
                ];
                prioritizedKeys.forEach((key) => {
                  if (key in value) {
                    visit(value[key]);
                  }
                });
                Object.keys(value).forEach((key) => {
                  if (!prioritizedKeys.includes(key)) {
                    visit(value[key]);
                  }
                });
              }
            };

            sources.forEach(visit);
            return results;
          };

          if (payload && typeof payload === "object") {
            const detailPayload =
              payload.detail && typeof payload.detail === "object"
                ? payload.detail
                : null;
            const errorCode =
              typeof payload.error === "string" && payload.error
                ? payload.error
                : typeof detailPayload?.error === "string"
                ? detailPayload.error
                : null;
            const normalizedErrorCode = errorCode?.toLowerCase() ?? null;

            if (normalizedErrorCode === "missing credentials") {
              const missingMessages = gatherMessages(
                payload.details,
                payload.message,
                payload.detail,
                detailPayload?.details,
                detailPayload?.message,
                detailPayload,
              );

              if (missingMessages.length > 0) {
                const message = missingMessages[0];
                if (/faltan credenciales/i.test(message)) {
                  return { message, reason: "missing-credentials" };
                }
                if (/PULLPILOT_TOKEN/i.test(message)) {
                  return {
                    message: `Faltan credenciales. ${message}`,
                    reason: "missing-credentials",
                  };
                }
                return { message, reason: "missing-credentials" };
              }

              return {
                message:
                  "Faltan credenciales. Introduce el token proporcionado para continuar.",
                reason: "missing-credentials",
              };
            }

            const genericMessages = gatherMessages(
              payload.detail,
              payload.description,
              payload.message,
              payload.details,
              payload.error,
            );
            if (genericMessages.length > 0) {
              return {
                message: genericMessages[0],
                reason: normalizedErrorCode || "generic",
              };
            }

            if (normalizedErrorCode) {
              return { ...defaultResult, reason: normalizedErrorCode };
            }
          } else if (typeof payload === "string" && payload.trim()) {
            return { message: payload.trim(), reason: "string-payload" };
          }

          return defaultResult;
        };

        const resolveUnauthorizedMessage = (error, fallbackMessage) =>
          resolveUnauthorizedDetails(error, fallbackMessage).message;

        const buildMissingCredentialsMessage = (message) => {
          const trimmed = typeof message === "string" ? message.trim() : "";
          const parts = [];
          if (trimmed) {
            parts.push(trimmed);
          }
          if (!/PULLPILOT_TOKEN/i.test(trimmed)) {
            parts.push(
              "Configura la variable de entorno PULLPILOT_TOKEN en el servidor y reinícialo.",
            );
          } else {
            parts.push("Reinicia el servidor después de actualizar PULLPILOT_TOKEN.");
          }
          parts.push(
            "El token introducido se conservará y se reutilizará automáticamente cuando el backend acepte credenciales.",
          );
          return parts.join(" ").trim();
        };

        const handleUnauthorized = (
          error,
          fallbackMessage = "El token ha caducado o es incorrecto. Introduce uno nuevo.",
        ) => {
          const { message, reason } = resolveUnauthorizedDetails(error, fallbackMessage);
          if (reason === "missing-credentials") {
            const finalMessage = buildMissingCredentialsMessage(message);
            showLoginPrompt("error", finalMessage);
            return;
          }

          const clearStatus = auth.clearToken();
          const storageOutcome = processStorageStatus(clearStatus, { silent: true });
          loginForm?.reset();
          const finalMessage = storageOutcome.handled
            ? `${message} ${storageOutcome.message}`
            : message;
          showLoginPrompt("error", finalMessage);
        };

        const authorizedFetch = async (input, options = {}) => {
          const token = auth.getToken();
          if (!token) {
            throw createUnauthorizedError();
          }

          const headers = new Headers(options.headers || {});
          if (!headers.has("Authorization")) {
            headers.set("Authorization", `Bearer ${token}`);
          }

          let requestInput = input;
          if (requestInput instanceof Request) {
            requestInput = new Request(buildApiUrl(requestInput.url), requestInput);
          } else if (requestInput instanceof URL || typeof requestInput === "string") {
            requestInput = buildApiUrl(requestInput);
          }

          let response;
          try {
            response = await fetch(requestInput, { ...options, headers });
          } catch (error) {
            throw error;
          }

          if (response.status === 401) {
            const unauthorizedError = createUnauthorizedError();
            try {
              unauthorizedError.payload = await response.clone().json();
            } catch (error) {
              // Ignorar si la respuesta no contiene JSON.
            }
            handleUnauthorized(
              unauthorizedError,
              "El token ha caducado o es incorrecto. Introduce uno nuevo.",
            );
            throw unauthorizedError;
          }

          return response;
        };

        const escapeSelector = (value) => {
          const stringValue = String(value);
          if (typeof CSS !== "undefined" && typeof CSS.escape === "function") {
            return CSS.escape(stringValue);
          }
          return stringValue.replace(/([\s!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~])/g, "\\$1");
        };

        const normalizeStatusMessage = (message) => {
          if (message && typeof message === "object") {
            const summary =
              typeof message.summary === "string" && message.summary.trim().length
                ? message.summary.trim()
                : typeof message.text === "string"
                ? message.text
                : typeof message.message === "string"
                ? message.message
                : "";
            const detailsSource = Array.isArray(message.details)
              ? message.details
              : message.details != null
              ? [message.details]
              : [];
            const details = detailsSource
              .map((detail) =>
                detail == null
                  ? null
                  : typeof detail === "string"
                  ? detail
                  : typeof detail === "object"
                  ? detail.message || detail.text || detail.detail || JSON.stringify(detail)
                  : String(detail)
              )
              .filter((detail) => typeof detail === "string" && detail.trim().length)
              .map((detail) => detail.trim());
            return { summary, details };
          }
          if (typeof message === "string") {
            return { summary: message, details: [] };
          }
          return { summary: message != null ? String(message) : "", details: [] };
        };

        const showStatus = (element, message, kind = "info") => {
          if (!element) return;
          const { summary, details } = normalizeStatusMessage(message);
          element.textContent = "";
          if (summary) {
            const summaryNode = document.createElement("span");
            summaryNode.textContent = summary;
            element.appendChild(summaryNode);
          }
          if (details.length) {
            const list = document.createElement("ul");
            details.forEach((detail) => {
              const item = document.createElement("li");
              item.textContent = detail;
              list.appendChild(item);
            });
            element.appendChild(list);
          }
          element.hidden = false;
          element.classList.toggle("success", kind === "success");
          element.classList.toggle("error", kind === "error");
        };

        const hideStatus = (element) => {
          if (!element) return;
          element.hidden = true;
          element.classList.remove("success", "error");
          element.textContent = "";
        };

        const clearFieldErrors = () => {
          if (!fieldsContainer) return;
          fieldsContainer.querySelectorAll(".config-field.is-error").forEach((field) => {
            field.classList.remove("is-error");
            field
              .querySelectorAll(".value-input, textarea[data-multiline]")
              .forEach((control) => control.removeAttribute("aria-invalid"));
          });
        };

        const applyFieldErrorHighlights = (details) => {
          if (!fieldsContainer) return [];
          const entries = Array.isArray(details) ? details : details != null ? [details] : [];
          const messages = [];
          entries.forEach((entry) => {
            if (entry == null) {
              return;
            }
            if (typeof entry === "string") {
              const trimmed = entry.trim();
              if (trimmed) {
                messages.push(trimmed);
              }
              return;
            }
            if (typeof entry === "object") {
              const fieldName = entry.field || entry.name || entry.key || null;
              const rawMessage =
                entry.message || entry.error || entry.detail || JSON.stringify(entry);
              const trimmedMessage =
                typeof rawMessage === "string" && rawMessage.trim().length
                  ? rawMessage.trim()
                  : typeof rawMessage === "string"
                  ? rawMessage
                  : String(rawMessage);
              if (fieldName) {
                const selector = `.config-field[data-name="${escapeSelector(fieldName)}"]`;
                const field = fieldsContainer.querySelector(selector);
                if (field) {
                  field.classList.add("is-error");
                  field
                    .querySelectorAll(".value-input, textarea[data-multiline]")
                    .forEach((control) => control.setAttribute("aria-invalid", "true"));
                }
                messages.push(`${fieldName}: ${trimmedMessage}`);
              } else if (trimmedMessage) {
                messages.push(trimmedMessage);
              }
              return;
            }
            messages.push(String(entry));
          });
          return messages;
        };

        const buildErrorStatusPayload = (data) => {
          const summary =
            data && typeof data.error === "string" && data.error.trim().length
              ? data.error.trim()
              : "No se pudo guardar la configuración.";
          const details = applyFieldErrorHighlights(data?.details);
          return { summary, details };
        };

        const booleanValue = (value) => {
          if (typeof value === "boolean") return value;
          if (typeof value === "string") return value.toLowerCase() === "true";
          return Boolean(value);
        };

        const createField = (variable, values, multilineValues, multilineSet) => {
          const wrapper = document.createElement("div");
          wrapper.className = "config-field";
          wrapper.dataset.name = variable.name;

          const label = document.createElement("label");
          label.htmlFor = `field-${variable.name}`;

          const isBaseDirField = variable.name === "BASE_DIR";
          if (isBaseDirField) {
            label.textContent = "Carpeta de proyectos docker-compose";
          } else {
            label.textContent = variable.name;
          }
          wrapper.appendChild(label);

          const inputContainer = document.createElement("div");
          inputContainer.className = "field-input";

          const hasValue =
            values && Object.prototype.hasOwnProperty.call(values, variable.name);
          const defaultValue = hasValue ? values[variable.name] : variable.default;
          let control;

          if (isBaseDirField) {
            control = document.createElement("input");
            control.type = "text";
            control.id = `field-${variable.name}`;
            control.classList.add("value-input", "base-dir-input");
            control.dataset.type = variable.type;
            control.placeholder =
              variable.default && String(variable.default).trim().length
                ? variable.default
                : "/srv/compose";
            control.spellcheck = false;
            if (variable.constraints?.pattern) {
              control.pattern = variable.constraints.pattern;
            }
            control.value = defaultValue ?? "";
          } else if (variable.type === "boolean") {
            control = document.createElement("input");
            control.type = "checkbox";
            control.id = `field-${variable.name}`;
            control.className = "value-input";
            control.dataset.type = "boolean";
            control.checked = booleanValue(defaultValue);
          } else if (
            variable.constraints && Array.isArray(variable.constraints.allowed_values) &&
            variable.constraints.allowed_values.length > 0
          ) {
            control = document.createElement("select");
            control.id = `field-${variable.name}`;
            control.className = "value-input";
            control.dataset.type = variable.type;
            const allowed = variable.constraints.allowed_values;
            allowed.forEach((option) => {
              const opt = document.createElement("option");
              opt.value = option;
              opt.textContent = option;
              if (String(option) === String(defaultValue)) {
                opt.selected = true;
              }
              control.appendChild(opt);
            });
          } else {
            control = document.createElement(variable.multiline ? "textarea" : "input");
            if (variable.multiline) {
              control.classList.add("multiline-input");
            }
            control.id = `field-${variable.name}`;
            control.classList.add("value-input");
            control.dataset.type = variable.type;
            if (variable.type === "integer") {
              control.type = "number";
              control.step = "1";
            } else if (!variable.multiline) {
              control.type = "text";
            }
            control.value = defaultValue ?? "";
          }

          if (control) {
            control.setAttribute("aria-describedby", `field-${variable.name}-description`);
          }
          inputContainer.appendChild(control);

          const descriptionId = `field-${variable.name}-description`;

          if (multilineSet.has(variable.name)) {
            const area = document.createElement("textarea");
            area.className = "multiline-input";
            area.id = `field-${variable.name}-content`;
            area.dataset.multiline = variable.name;
            area.placeholder =
              variable.description || `Introduce el contenido asociado a ${variable.name}`;
            area.setAttribute("aria-labelledby", descriptionId);
            area.value = multilineValues?.[variable.name] ?? "";
            inputContainer.appendChild(area);
          }

          wrapper.appendChild(inputContainer);

          const description = document.createElement("p");
          description.className = "field-description";
          description.id = descriptionId;
          if (isBaseDirField) {
            const helpLines = [
              "Ruta absoluta de la carpeta donde se buscarán los proyectos Docker Compose.",
              "Debe contener los archivos docker-compose.yml en sus subdirectorios para que el escaneo funcione.",
            ];
            if (variable.description) {
              helpLines.unshift(variable.description);
            }
            if (helpLines.length) {
              description.textContent = helpLines[0];
              helpLines.slice(1).forEach((line) => {
                description.appendChild(document.createElement("br"));
                const span = document.createElement("span");
                span.textContent = line;
                description.appendChild(span);
              });
            }
          } else {
            description.textContent = variable.description || "Sin descripción";
          }

          if (variable.default !== undefined && variable.default !== null && String(variable.default).length) {
            const defaultTag = document.createElement("span");
            defaultTag.className = "field-default";
            defaultTag.textContent = `Valor por defecto: ${variable.default}`;
            description.appendChild(document.createElement("br"));
            description.appendChild(defaultTag);
          }

          wrapper.appendChild(description);
          return wrapper;
        };

        const populateConfig = (data) => {
          const { schema, values, multiline, meta } = data;
          fieldsContainer.innerHTML = "";
          const multilineSet = new Set(meta?.multiline_fields ?? []);
          schema?.variables?.forEach((variable) => {
            const field = createField(variable, values, multiline, multilineSet);
            fieldsContainer.appendChild(field);
          });
          lastConfigSnapshot = data;
        };

        const readFormValues = () => {
          const payload = { values: {}, multiline: {} };
          fieldsContainer.querySelectorAll(".config-field").forEach((field) => {
            const name = field.dataset.name;
            if (!name) return;
            const control = field.querySelector(".value-input");
            if (!control) return;
            const type = control.dataset.type;
            if (type === "boolean") {
              payload.values[name] = control.checked;
            } else if (type === "integer") {
              payload.values[name] = control.value === "" ? null : Number(control.value);
            } else {
              const rawValue = control.value;
              payload.values[name] = name === "BASE_DIR" ? rawValue.trim() : rawValue;
            }
            const multilineControl = field.querySelector("textarea[data-multiline]");
            if (multilineControl) {
              payload.multiline[name] = multilineControl.value;
            }
          });
          if (Object.keys(payload.multiline).length === 0) {
            delete payload.multiline;
          }
          return payload;
        };

        const fetchConfig = async () => {
          hideStatus(configStatus);
          try {
            const response = await authorizedFetch(buildApiUrl("config"));
            if (!response.ok) {
              throw new Error(`Error HTTP ${response.status}`);
            }
            const data = await response.json();
            populateConfig(data);
            showStatus(configStatus, "Configuración cargada correctamente.", "success");
            setTimeout(() => hideStatus(configStatus), 2500);
            return true;
          } catch (error) {
            console.error(error);
            if (error?.message === "UNAUTHORIZED") {
              showStatus(
                configStatus,
                "No se pudo cargar la configuración: introduce un token válido.",
                "error",
              );
            } else {
              showStatus(
                configStatus,
                "Token válido, pero el backend no devolvió la configuración. Revisa el servicio e inténtalo de nuevo.",
                "error",
              );
            }
            return false;
          }
        };

        const submitConfig = async (event) => {
          event.preventDefault();
          hideStatus(configStatus);
          clearFieldErrors();
          const payload = readFormValues();
          try {
            const response = await authorizedFetch(buildApiUrl("config"), {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            const data = await response.json().catch(() => null);
            if (!response.ok) {
              const requestError = new Error("REQUEST_FAILED");
              requestError.status = response.status;
              requestError.data = data;
              throw requestError;
            }
            if (data) {
              populateConfig(data);
            }
            showStatus(configStatus, "Cambios guardados.", "success");
          } catch (error) {
            console.error(error);
            if (error?.message === "UNAUTHORIZED") {
              showStatus(
                configStatus,
                "No se pudo guardar la configuración porque falta un token válido.",
                "error",
              );
              return;
            }
            if (error?.data) {
              const statusPayload = buildErrorStatusPayload(error.data);
              showStatus(configStatus, statusPayload, "error");
              return;
            }
            showStatus(
              configStatus,
              "No se pudo guardar la configuración. Revisa los datos e inténtalo de nuevo.",
              "error",
            );
          }
        };

        const resetConfig = () => {
          if (!lastConfigSnapshot) return;
          populateConfig(lastConfigSnapshot);
          showStatus(configStatus, "Se restauraron los valores cargados.");
          setTimeout(() => hideStatus(configStatus), 2500);
        };

        const fetchLogs = async (selectedName = null) => {
          hideStatus(logsStatus);
          const logsUrl = new URL(buildApiUrl("logs"));
          if (selectedName) {
            logsUrl.searchParams.set("name", selectedName);
          }
          const url = logsUrl.toString();
          try {
            const response = await authorizedFetch(url);
            if (!response.ok) {
              throw new Error(`Error HTTP ${response.status}`);
            }
            const data = await response.json();
            renderLogs(data);
            return true;
          } catch (error) {
            console.error(error);
            if (error?.message === "UNAUTHORIZED") {
              showStatus(logsStatus, "Introduce un token válido para consultar los logs.", "error");
              logContent.textContent = "Introduce un token válido para ver los logs.";
            } else {
              showStatus(logsStatus, "No se pudieron cargar los logs.", "error");
              logContent.textContent = "Sin datos disponibles.";
            }
            return false;
          }
        };

        const renderLogs = (data) => {
          const files = Array.isArray(data.files) ? data.files : [];
          logSelect.innerHTML = "";

          if (files.length === 0) {
            const option = document.createElement("option");
            option.textContent = "Sin archivos de log";
            option.disabled = true;
            option.selected = true;
            logSelect.appendChild(option);
            logSelect.disabled = true;
            logContent.textContent = "No se encontraron archivos .log en el directorio configurado.";
            logMeta.textContent = data.log_dir ? `Directorio: ${data.log_dir}` : "";
            return;
          }

          logSelect.disabled = false;
          files.forEach((file) => {
            const option = document.createElement("option");
            option.value = file.name;
            const formattedDate = file.modified
              ? new Date(file.modified).toLocaleString()
              : "sin fecha";
            option.textContent = `${file.name} · ${formattedDate}`;
            logSelect.appendChild(option);
          });

          const selectedName = data.selected?.name || logSelect.options[0]?.value;
          if (selectedName) {
            logSelect.value = selectedName;
          }

          if (data.selected?.content) {
            logContent.textContent = data.selected.content;
          } else if (data.selected) {
            logContent.textContent = "Archivo sin contenido o no legible.";
          } else {
            logContent.textContent = "No hay contenido disponible para el archivo seleccionado.";
          }

          const size = data.selected?.size;
          const modified = data.selected?.modified ? new Date(data.selected.modified).toLocaleString() : "";
          logMeta.textContent = `${data.log_dir ? `Directorio: ${data.log_dir}` : ""}${
            modified ? ` · Última modificación: ${modified}` : ""
          }${size ? ` · Tamaño: ${size} bytes` : ""}`;
        };

        const handleSuccessfulLogin = async ({
          showSuccessMessage = true,
          storageStatus = null,
        } = {}) => {
          setAuthState(true);
          hideStatus(configStatus);
          hideStatus(logsStatus);
          if (loginForm) {
            loginForm.reset();
          }
          const configLoaded = await fetchConfig();
          await fetchLogs();
          const storageOutcome = processStorageStatus(storageStatus, { silent: true });
          const storageMessage = storageOutcome.handled ? storageOutcome.message : "";
          if (!configLoaded) {
            const baseMessage =
              "Token validado, pero no se pudo cargar la configuración. Revisa el servicio e inténtalo de nuevo.";
            const combinedMessage = storageMessage
              ? `${baseMessage} ${storageMessage}`
              : baseMessage;
            showLoginMessage(combinedMessage, "error");
          } else if (storageOutcome.handled) {
            showLoginMessage(storageMessage, storageOutcome.tone || "error");
          } else if (showSuccessMessage) {
            showLoginMessage("Token validado. Puedes usar la interfaz con normalidad.", "success");
          } else {
            showLoginMessage("", "info");
          }
        };

        const showLoginPrompt = (
          tone = "info",
          message = "Introduce el token bearer para continuar. Marca «Recordar token» solo si el equipo es de confianza.",
        ) => {
          setAuthState(false);
          showLoginMessage(message, tone);
          tokenInput?.focus();
        };

        loginForm?.addEventListener("submit", async (event) => {
          event.preventDefault();
          const value = tokenInput?.value?.trim() ?? "";
          if (!value) {
            showLoginMessage("Debes introducir un token para continuar.", "error");
            tokenInput?.focus();
            return;
          }
          showLoginMessage("Verificando token…", "info");
          try {
            const shouldPersist = rememberCheckbox?.checked ?? false;
            const verification = await verifyToken(value, { persist: shouldPersist });
            await handleSuccessfulLogin({ storageStatus: verification?.storageStatus });
          } catch (error) {
            console.error(error);
            if (error?.message === "UNAUTHORIZED" || error?.status === 401) {
              const message = resolveUnauthorizedMessage(
                error,
                "El token proporcionado no está autorizado. Vuelve a intentarlo.",
              );
              showLoginMessage(message, "error");
            } else if (error?.message === "NETWORK_ERROR") {
              showLoginMessage(
                "No se pudo verificar el token. Revisa la conexión e inténtalo de nuevo.",
                "error",
              );
            } else if (error?.message === "TOKEN_REQUIRED") {
              showLoginMessage("Debes introducir un token para continuar.", "error");
            } else {
              showLoginMessage("No se pudo verificar el token. Inténtalo de nuevo.", "error");
            }
          }
        });

        const clearSession = (
          message = "Introduce el token bearer para continuar.",
          tone = "info",
        ) => {
          const clearStatus = auth.clearToken();
          const storageOutcome = processStorageStatus(clearStatus, { silent: true });
          loginForm?.reset();
          if (storageOutcome.handled) {
            showLoginPrompt("error", storageOutcome.message);
            return;
          }
          showLoginPrompt(tone, message);
        };

        clearTokenButton?.addEventListener("click", () => {
          clearSession("Se olvidó el token guardado. Introduce uno nuevo.");
        });

        logoutButton?.addEventListener("click", () => {
          clearSession("Sesión cerrada. Introduce un token válido para continuar.");
        });

        form.addEventListener("submit", submitConfig);
        resetButton.addEventListener("click", resetConfig);
        logSelect.addEventListener("change", (event) => {
          const { value } = event.target;
          if (!value || logSelect.disabled) return;
          fetchLogs(value);
        });
        refreshLogs.addEventListener("click", () => {
          const selected = logSelect.disabled ? null : logSelect.value;
          fetchLogs(selected || null);
        });

        if (storedToken) {
          showLoginMessage("Verificando token guardado…", "info");
          verifyToken(storedToken, { persist: true })
            .then((verification) =>
              handleSuccessfulLogin({
                showSuccessMessage: false,
                storageStatus: verification?.storageStatus,
              }),
            )
            .catch((error) => {
              console.error(error);
              const isUnauthorized = error?.message === "UNAUTHORIZED" || error?.status === 401;
              if (isUnauthorized) {
                const { message, reason } = resolveUnauthorizedDetails(
                  error,
                  "El token guardado no es válido. Introduce uno nuevo.",
                );
                if (reason === "missing-credentials") {
                  const finalMessage = buildMissingCredentialsMessage(message);
                  showLoginPrompt("error", finalMessage);
                  return;
                }

                const clearStatus = auth.clearToken();
                const storageOutcome = processStorageStatus(clearStatus, { silent: true });
                const finalMessage = storageOutcome.handled
                  ? `${message} ${storageOutcome.message}`
                  : message;
                showLoginPrompt("error", finalMessage);
              } else if (error?.message === "NETWORK_ERROR") {
                showLoginPrompt(
                  "error",
                  "No se pudo verificar el token guardado por un problema de red. Revisa la conexión e inténtalo de nuevo; el token seguirá guardado.",
                );
              } else {
                showLoginPrompt(
                  "error",
                  "No se pudo verificar el token guardado. Inténtalo de nuevo o introduce uno nuevo.",
                );
              }
            });
        } else {
          if (initialStorageOutcome.handled) {
            showLoginPrompt("error", initialStorageOutcome.message);
          } else {
            showLoginPrompt();
          }
        }
      })();
    </script>
  </body>
</html>
